---
title: 分享一次项目压测导致的并发问题
date: 2023-12-06 18:50:32
permalink: /more/251dfe/
categories:
  - 工作分享
tags:
  - 压测
  - 并发
author: 
  name: zhaoyb
  link: https://github.com/zhaoyb-coder
---

# 分享一次项目压测导致的并发问题

------

2023年11月份左右，开发的项目进入压测阶段，压测第一阶段的单据保存，直接40%~60%的线程都提示测试失败，具体失败日志全是数据库层面抛出的`主键冲突`异常，时间紧，任务重，因为这一块的业务全是我写的，所以整个排查工作就落在我的身上。



## 1、前言：

排查之前先大致了解一下这个项目结构和业务流程，整体项目以SpringBoot为底层框架、以DDD思想为核心搭建的。DDD主推的领域模型的概念也在项目中有所体现，下图简单展示了保存单据这个业务主要经历的流程

![image-20231206192404165](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20231206192404165.png)

大致分为四个阶段：

1、根据前端参数billType来判断需要当前业务需要执行哪个Service，负责的领域对象是哪个，分别获取其实例

2、把前端参数注入到BO实例对象中，进行对象属性赋值

3、把BO对象当做参数去调用Service的add方法

4、Service出口统一把BO转换成PO进行数据库操作

伪代码如下：

领域服务实例：

```java
@Service("USER_SERVICE")
public class UserServiceImpl implements AbstractService{
    
    public void add(UserBO userBO){
        //do something
    };
}
```

领域对象实例：

```java
@Component("USER_BO")
public class UserBO extends AbstractBO {
    private String name;
    private String id;
}
```

业务伪代码：

```java
public class UserAction{
    
    @Autowire
    private Map<String,AbstractService> serviceMap;
    
    @Autowire
    private Map<String,AbstractBO> BOMap;
    
    public void add(String billType,Object param){
        //1、获取Service实例
        AbstractService service = serviceMap.get(billType+"_SERVICE");
        // 2、获取BO实例
        AbstractBO BO = BOMap.get(billType+"_BO");
        // 3、工具类进行属性赋值 param -> BO
        BeanUtil.Transform(param,BO);
        // 4、执行业务
        service.add(BO);
        // 5、转换成数据库对象
        User po = new User();
        BeanUtil.Transform(BO,PO);
        // 6、调用入库接口
        dao.insert(po);
    }
}
```

## 2、分析过程

最开始我把目标定位在第二步BeanUtil.Transform(param,BO);我初步是怀疑这个自己写得转换类有线程安全问题，导致了压测失败

这个转换类中的Transform是静态方法，所有线程共享一个实例，内部可变化的私有属性都是线程不安全的，但是在开发过程中我也都提前预料到了这些问题，这些可以变化的属性我都用ThreadLocal进行的包装，应该是不会存在线程安全问题

然后开始了debug阶段，本地使用ApiFox进行接口压测，在IEDA中进行多线程debug，在每个阶段都进行数据记录，