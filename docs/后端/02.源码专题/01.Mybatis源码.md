---
title: Mybatis源码
date: 2023-12-10 11:07:14
permalink: /be/935152/
categories:
  - 后端
  - 源码专题
tags:
  - 
author: 
  name: zhaoyb
  link: https://github.com/zhaoyb-coder

---

## 一、整体调用流程

代码实现：
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163004.png)
代码流程解析
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163112.png)

### 1、项目使用的设计模式整理：

- 适配器模式
  - logging包：JakartaCommonsLoggingImpl是一个典型的对象适配器，内部持有了Log对象，然后把所有方法委托给了该对象
- 模板模式
  - Type包：BaseTypeHandler中的getResult方法完成了一系列 的异常处理工作，而与类型相关的getNullableResult操作则通过抽象方法交给具体的类型处理器，这就是典型的模板模式
- 单例模式
  - IO包：VFS包含的VFSHolder就是一个单例
- 代理模式
  - IO包：JBoss6VFS类中的ViryualFile是JBoss中的ViryualFile的静态代理类
  - logging：jdbc子包使用代理模式，让mybatis能够打印jdbc的操作日志，方便进行调试
  - binding包：数据库接入MapperProxy
- 建造者模式：
  - builder包
- 工厂模式
  - datasource包
- 装饰器模式
  - cache包
- 责任链模式
  - plugin包

## 二、源码结构展示

![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210114653.png)
基础功能包：

- exceptions
- reflection
- annotations
- lang
- type
- io
- logging
- parsing

配置解析包：

- binding
- builder
- mapping
- scripting
- datasource

核心操作包：

- jdbc
- cache
- transaction
- cursor
- executor
- session
- plugin

![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210160646.png)

## 三、源码包解析

### 1、reflection包（反射包）

#### 1.1、factory包（工厂包）

```java
public interface ObjectFactory {

  default void setProperties(Properties properties) {
  }

  <T> T create(Class<T> type);

  <T> T create(Class<T> type, List<Class<?>> constructorArgTypes, List<Object> constructorArgs);

  <T> boolean isCollection(Class<T> type);

}

```

> DefaultObjectFactory为当前接口的默认实现

```java
public class DefaultObjectFactory implements ObjectFactory, Serializable {

  private static final long serialVersionUID = -8855120656740914948L;

  @Override
  public <T> T create(Class<T> type) {
    return create(type, null, null);
  }

  @SuppressWarnings("unchecked")
  @Override
  public <T> T create(Class<T> type, List<Class<?>> constructorArgTypes, List<Object> constructorArgs) {
    Class<?> classToCreate = resolveInterface(type);
    // we know types are assignable
    // 创建类型实例
    return (T) instantiateClass(classToCreate, constructorArgTypes, constructorArgs);
  }

  /**
   * 创建类的实例
   * @param type 要创建实例的类
   * @param constructorArgTypes 构造方法入参类型
   * @param constructorArgs 构造方法入参
   * @param <T> 实例类型
   * @return 创建的实例
   */
  private  <T> T instantiateClass(Class<T> type, List<Class<?>> constructorArgTypes, List<Object> constructorArgs) {
    try {
      // 构造方法
      Constructor<T> constructor;
      if (constructorArgTypes == null || constructorArgs == null) { // 参数类型列表为null或者参数列表为null
        // 因此获取无参构造函数
        constructor = type.getDeclaredConstructor();
        try {
          // 使用无参构造函数创建对象
          return constructor.newInstance();
        } catch (IllegalAccessException e) {
          // 如果发生异常，则修改构造函数的访问属性后再次尝试
          if (Reflector.canControlMemberAccessible()) {
            constructor.setAccessible(true);
            return constructor.newInstance();
          } else {
            throw e;
          }
        }
      }

      // 根据入参类型查找对应的构造器
      constructor = type.getDeclaredConstructor(constructorArgTypes.toArray(new Class[constructorArgTypes.size()]));
      try {
        // 采用有参构造函数创建实例
        return constructor.newInstance(constructorArgs.toArray(new Object[constructorArgs.size()]));
      } catch (IllegalAccessException e) {
        if (Reflector.canControlMemberAccessible()) {
          // 如果发生异常，则修改构造函数的访问属性后再次尝试
          constructor.setAccessible(true);
          return constructor.newInstance(constructorArgs.toArray(new Object[constructorArgs.size()]));
        } else {
          throw e;
        }
      }
    } catch (Exception e) {
      // 收集所有的参数类型
      String argTypes = Optional.ofNullable(constructorArgTypes).orElseGet(Collections::emptyList)
          .stream().map(Class::getSimpleName).collect(Collectors.joining(","));
      // 收集所有的参数
      String argValues = Optional.ofNullable(constructorArgs).orElseGet(Collections::emptyList)
          .stream().map(String::valueOf).collect(Collectors.joining(","));
      throw new ReflectionException("Error instantiating " + type + " with invalid types (" + argTypes + ") or values (" + argValues + "). Cause: " + e, e);
    }
  }

  // 判断要创建的目标对象的类型，即如果传入的是接口则给出它的一种实现
  protected Class<?> resolveInterface(Class<?> type) {
    Class<?> classToCreate;
    if (type == List.class || type == Collection.class || type == Iterable.class) {
      classToCreate = ArrayList.class;
    } else if (type == Map.class) {
      classToCreate = HashMap.class;
    } else if (type == SortedSet.class) { // issue #510 Collections Support
      classToCreate = TreeSet.class;
    } else if (type == Set.class) {
      classToCreate = HashSet.class;
    } else {
      classToCreate = type;
    }
    return classToCreate;
  }

  @Override
  public <T> boolean isCollection(Class<T> type) {
    return Collection.class.isAssignableFrom(type);
  }

}
```

#### 1.2、invoker包(执行器)

> 该子包中的类能够基于反射实现对象方法的调用和对象属性的读写

![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210161158.png)

```java
public interface Invoker {
  // 方法执行调用器
  Object invoke(Object target, Object[] args) throws IllegalAccessException, InvocationTargetException;
  // 传入参数或者传出参数的类型（如有一个入参就是入参，否则是出参）
  Class<?> getType();
}
```

> 三个默认实现：
> GetFieldInvoker：负责对象属性的读操作
> SetFieldInvoker：负责对象属性的写操作
> MethodInvoker：负责对象其它方法的操作

#### 1.3、property包（属性）

> 该子包中的类用来完成与对象属性相关的操作

- PropertyCopier：属性拷贝器，可以方便的把一个对象的属性复制到另一个对象中
  - copyBeanProperties方法的工作原理非常简单：通过反射获取类的所有属性，然后依次将这些属性值从源对象复制出来并赋给目标对象。但是要注意一点，该属性复制器无法完成继承得来的属性的复制，因为 getDeclaredFields方法返回的属性中不包含继承属性
- PropertyNamer：属性（包括属性方法）名称处理器
- PropertyTokenizer：是一个属性标记器。传入一个形如“student[sId].name”的字符串后，该标记器会将其拆分开，放入各个属性中

#### 1.4、wrapper包（对象包装器）

> 使用装饰器模式对各种类型的对象进行进一步的封装，为其增加一些功能，使之更易于使用

![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210161638.png)

- **ObjectWrapperFactory**:是对象包装器工厂的接口，DefaultObjectWrapperFactory是默认实现，该默认节点没有实现任何功能，Mybatis也允许用户通过配置文件中的objcetWrapperFactory节点，来注入新的ObjectWrapperFactory
- **ObjectWrapper**:是所有对象包装器的总接口
- **BeanWrapper**：包含了一个Bean的对象信息、类型信息、并提供了更多的功能，一个bean通过BeanWrapper包装后就可以暴露大量的易用方法，可以简单的实现对其方法、属性的操作
  get：获得被包装对象某个属性的值
  set：设置被包装对象某个属性的值
  findProperty：找到对应的属性值
  getGetterNames：获取所有属性的get方法名称
  getSetterNames：获得所有属性的set方法名称
  getGetterType：获取指定属性的get方法的类型
  getSetterType：获取指定属性的set方法的类型
  hasGetter：判断某个属性是否有对应的get方法
  hasSetter：判断某个属性是否有对应的set方法
  instantiatePropertyValue：实例化某个属性的值
- **MapWrapper**：对于Map类型的包装
- **CollectionWrapper**：对于集合类型的封装

#### 1.5、reflector(反射核心类)

![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210161926.png)

> 负责对一个类进行反射解析，并将解析后的结果储存起来，解析一个类的过程是用构造函数触发的，逻辑非常清晰

![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210162029.png)

#### 1.6、ExceptionUtil(异常拆包工具)

> 提供了一个拆包异常的工具方法unwrapThrowable,该方法将InvocationTargeException和UndeclaredThrowableException这两类异常进行拆包，得到其中真正的异常

#### 1.7、ParamNameResolver(参数名解析器)

> 功能是按照顺序列出方法中的虚参，并对实参进行名称标注
> 主要涉及的是对字符串的处理

#### 1.8、TypeParameterResolver（泛型参数解析器）

> 功能是帮助Mybatis推断出属性、返回值、输入参数中的泛型的具体类型
> 比如List\\<\\T> 中的这个T具体是什么类型，User? Map?等

对外提供了三个方法

- resolverFieldType 解析属性的泛型
- resolverReturnType 解析方法返回值的泛型
- resolverParamTypes 解析方法输入参数的泛型

核心方法resolverType

```java
    /**
     * 解析变量的实际类型
     * @param type 变量的类型
     * @param srcType 变量所属于的类
     * @param declaringClass 定义变量的类
     * @return 解析结果
     */
    private static Type resolveType(Type type, Type srcType, Class<?> declaringClass) {
        if (type instanceof TypeVariable) { // 如果是类型变量，例如“Map<K，V>”中的“K”、“V”就是类型变量。
            return resolveTypeVar((TypeVariable<?>) type, srcType, declaringClass);
        } else if (type instanceof ParameterizedType) { // 如果是参数化类型，例如“Collection<String>”就是参数化的类型。
            return resolveParameterizedType((ParameterizedType) type, srcType, declaringClass);
        } else if (type instanceof GenericArrayType) { // 如果是包含ParameterizedType或者TypeVariable元素的列表
            return resolveGenericArrayType((GenericArrayType) type, srcType, declaringClass);
        } else {
            return type;
        }
    }
```

### 2、annotations包（注解包）

> java注解是一种标注。
> java中的类、方法、变量、参数、包等都可以被注解标注从而添加额外的信息

#### 2.1、元注解

- @Target:用来声明注解可以用在什么地方，值需要在枚举中获取，包括：
  - TYPE（类、接口、注解、枚举）
  - FIELD（字段）
  - METHOD（方法）
  - PARAMETER（参数）
  - CONSTRUCTOR（构造方法）
  - LOCAL_VARIABLE（本地变量）
  - ANNOTATION_TYPE（注解）
  - PACKAGE（包）
  - TYPE_PARAMTER（类型参数）
  - TYPE_USE（类型使用）
- @Retention:用来声明注解的声明周期
  - SOURCE:保留到源代码阶段，一般给编译器使用
  - CLASS：保留到类文件阶段，这是默认的生命周期，JVM运行时不包含这些信息
  - RUNTIME：保留到JVM运行时期
- @Documented:不需要设置具体的值，如果一个注解被Documented标注，则该注解会在javadoc中生成
- @Inherited:不需要设置具体的值，标识子类可以继承父类的该注解（只能继承，不能从接口继承）
- @Repeatable:表名该注解可以在同一个地方被重复使用

#### 2.2、Param注解

![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163412.png)
依赖开发工具可以找到Mybatis对于Param注解的解析是在ParamNameResolver构造方法中
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163444.png)

### 3、type包

> type包中的类有55个之多，在遇到这种繁杂的情况时，一定要注意归纳总结
> 归纳总结是阅读源码中非常好的方法

type包中的类可以分为6组

- 类型处理器：1个接口、1个基础实现类、1个辅助类、43个实现类
  - TypeHandler：类型处理器接口
  - BaseTypeHandlerr：类型处理器的基础实现
  - TypeReference：类型参考器
  - **TypeHandler：43个类型处理器
- 类型注册表：3个
  - SimpleTypeRegistry：基本类型注册表，内部使用Set维护了所有Java基本数据类型的集合
  - TypeAliasRegistry：类型别名注册表，内部使用HashMap为了所有类型的别名和类型的映射关系
  - TypeHandleRegistry：类型处理器注册表，内部维护了所有类型与对应类型处理器的映射关系
- 注解类：3个
  - Alias：使用该注解可以给类设置别名
  - MappedJdbcTypes：有时我们想使用自己的处理器来处理某些JDBC类型，只需创建BaseTypeHandler的子类，然后在上面加上该注解，声明它要处理的JDBC类型即可
  - MappedTypes：有时我们想使用自己的处理器来处理某些java类型，只需要创建BaseTypeHandler的子类，然后在上面增加该注解，声明它要处理的Java类型即可
- 异常类：1个
  - TypeException：表示与类型处理相关的异常
- 工具类：1个
  - ByteArrayUtils：提供数组转化的工具方法
- 枚举类：1个
  - JdbcType：在Enum中定义了所有的JDBC类型，类型来源于java.sql.Types

### 4、io包

> 完成mybatis中输入输出相关的操作

#### 4.1、vfs

> 磁盘文件有很多种，FAT、VFAT、NFS、NTFS等，不同文件系统的读写操作各不相同，VFS作为一个虚拟的文件系统，可以屏蔽底层的操作差异，提供统一的操作接口
> vfs的作用是在应用系统中寻找和读取资源文件

![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163512.png)
vfs包中相关的类主要是3个
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163541.png)
DefaultVFS：

> 作为默认的VFS实现，isVaild函数恒返回true，因此只要加载DefauktVFS类，就一定能够通过VFS类中的VFSHolder单例中的校验，并且在进行类校验时，DefaultVFS在整个列表的最后，所以可以作为兜底方案

- list（URL,String）:列出指定URL下符合条件的资源名称
- listResources（JarInputStream，String）：列出给定jar包中符合条件的资源名称
- findJarForResource（URL）：找出指定路径上的jar包，并返回jar包的准确路径
- getPackagePath(String)：将jar包名称转为路径
- isJar：判断指定路径上是否是jar包

JBoss6VFS：

> JBoss是基于J2EE的开源应用服务器

#### 4.2、classLoaderWrapper（类加载）

> 要把文件加载成类，需要类加载器的支持
> classLoaderWrapper内部封装了5种类加载器，这5中类加载器优先级由高到低，在读取类文件时，依次在5种类加载器中进行查找，查找到即返回结果

![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163559.png)

- 作为参数传入的类加载器，可能为null
- 系统默认的类加载器，未设置则为null
- 当前线程的线程上下文的类加载器
- 当前对象的类加载器
- 系统类加载器，在ClassLoaderWrapper构造方法中设置

classForName()

> 根据类名找出指定类的方法

#### 4.3、ResolverUtil（工具类）

> 主要完成类的筛选，筛选条件可以是：
> 1、类是否是某个接口或者类的子类
> 2、类是否具有某个注解

### 5、logging（日志包）

#### 5.1、日志等级：

- Fatal：致命等级的日志，发生了会导致应用程序退出的事件
- Error：错误等级的日志，发生了错误，但是不影响应用运行
- Warn：警告等级的日志，发生了异常，可能是潜在的错误
- Info：信息等级的日志，在一些粗粒度级别上需要强调的应用程序运行信息
- Debug：调试等级的日志，指一些细粒度的对于程序调试有帮助的信息
- Trace：跟踪等级的日志，指一些程序运行详细过程的信息

#### 5.2、LogFactory

> LogFactory生成目标对象的工作在静态代码块中被触发

![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163610.png)

#### 5.3、jdbc

> jdbc日志包存在的意义？
> Mybatis是ORM框架，负责数据库信息和java对象的互相映射，而不负责具体的数据库读写操作，具体的读写操作由JDBC完成，所以Mybatis的日志便不会包含JDBC的操作日志
> 但是有时候很多错误是JDBC导致的，因此JDBC日志是分析Mybatis框架报错的重要依据
> JDBC日志有自己的输出体系，会给调试工作带来困难，所以jdbc子包就是为了解决这个问题

![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163623.png)
BaseJdbcLogger的各个子类使用动态代理来实现日志的打印，比如ConnectionLogger
1、实现jdk动态代理
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163635.png)
2、BaseExecutor入口处调用ConnectionLogger生成代理对象
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163647.png)
3、执行invoker方法，进行日志打印

### 6、parsing包（XML解析）

> mybatis的配置文件和映射文件都是XML
> 在解析过程中，XPathParser 和 XNode是两个最为关键的类
> XPathParser内部封装了XPath对象，XPath是解析XML的利器

![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163657.png)

#### 6.1、GenericTokenParser 

> 通用的占位符解析器，比如sql中的{} # $都是这个解析器进行解析替换
> 类中唯一一个parse方法，该方法主要完成占位符的定位工作，然后把占位符的替换工作交给与其关联的TokenHandler处理，

例如传入的参数是
openToken:"${"
closeToken:"}"
向GenericTokenParser的parse方法传入的参数是"jdbc:mysql://127.0.0.1:3306/${dbname}"
则parse方法会将被"${" 和 "}"包围的dbname字符串解析出来，作为输入参数传入handler中的handleToken方法，然后用返回值替换${dbname}字符串

### 7、binding包（绑定关系）

> 主要用来处理java方法与SQL语句之间绑定关系的包
> binding包维护了映射接口中方法和数据库操作节点之间的关联关系
> 1、维护映射接口中的抽象方法与数据库操作节点之间的关联关系
> 2、为映射接口中的抽象方法接入对应的数据库操作

#### 7.1、数据库的接入

![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163710.png)

> 要想将一个数据库接入一个抽象方法中，首先要做的就是将一个数据库节点操作转化为一个方法，**MapperMethod**对象就表示数据库操作转化后的方法，每个MapperMethod对象都对应一个数据库操作节点，调用实例中的execute就可以触发节点中的SQL语句

MapperMethod：有两个属性（两个重要的内部类）
MethodSignature 方法签名（持有这个方法的详细信息）
SqlCommand sql语句（持有这个方法对应的SQL语句）
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163723.png)
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163734.png)

> SqlCommand构造方法主要通过传入的参数完成name和type的赋值，其中的resolveMappedStatement子方法是一切的关键。

只要调用MapperMethod的execute就可以触发具体的数据库操作

#### 7.2、数据库操作方法的接入

如何调用execute方法？
当调用映射接口中的方法时，java会去找接口 的实现类并执行该方法，但是映射接口是没有实现类的，为什么没有报错，而是去执行了MapperMethod的execute方法呢
答案就是动态代理MapperProxy

#### 7.3、抽象方法与数据库操作节点的关联

> 映射接口文件（xxxMapper.class）这么多，内置的抽象方法也很多，另一方面，映射文件（xxxMapper.xml）也很多，一切的对应关系怎么去维护呢？

Mybatis分两步解决了这个问题：
1、Mybatis将映射接口与MapperProxyFactory关联起来，这种关联关系是在MapperRegistry类的knownMappers属性中维护的
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210170309.png)
MapperProxyFactory的构造方法只有一个参数，便是映射接口，并且其余属性不允许修改，所以只要MapperProxyFactory对象确定了，MapperProxy也就确定了，于是，MapperRegistry中的knownMappers属性间接的将映射接口与MapperProxy对象关联起来
2、此时的范围已经缩小到一个映射接口或者一个MapperProxy对象内，由MapperProxy内部的methodCache属性维护接口方法和MapperMethod对象的对应关系
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163755.png)

通过这两步，生成的对应关系就如图所示
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163809.png)

#### 7.4、数据库操作接入总结

##### 7.4.1、初始化阶段：

Mybatis在初始化阶段会进行各个映射文件的解析，然后将各个数据库操作节点的信息记录到Configuration对象的mappedStatements中（结构是一个StrictMap表示一个不允许覆盖键值的HashMap）
在初始化阶段，扫描所有的映射接口，并根据映射接口创建与之关联的MapperProxyFactory，两者的关联关系由MapperResigtry维护，当调用MapperRegistry的getMapper方法，就会通过MapperProxyFactory创建一个MapperProxy对象作为映射接口的代理

##### 7.4.2、数据读写阶段

当映射接口有方法被调用时，会被代理对象MapperProxy劫持，触发MapperProxy内部的invoker方法，invoker方法会取出映射接口对应的MapperMethod对象
创建MapperMethod对象过程中，内部类SqlCommand的构造方法会去Configuratio对象的mappedStatements属性中根据当前映射接口名、方法名获取到前期已经存好的SQL语句
然后MapperMethod的execute方法被触发，方法内部会根据不同的SQL语句类型进行不同的数据库操作

### 8、builder包

#### 8.1、建造者基类和工具类

BaseBuilder是所有建造者的基类
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163821.png)
BaseBuilder类提供的工具方法大致分为以下几类：

- **ValueOf：类型转化函数，负责将输入参数转化为指定的类型，并支持默认值设置
- resolve**：字符串转枚举类型函数，根据字符串找出对应的枚举类型并返回
- createInstance：根据类型别名创建类型实例
- resolverTypeHandle：根据类型处理器别名返回类型处理器实例

#### 8.2、SqlSourceBuilder、StaticSqlSource

> SqlSource是一个接口，有4种实现，通过parse方法生产出StaticSqlSource对象

准确的说，SqlSourceBuilder能够将DynamicSqlSource和RawSqlSource中的#$替换掉，从而将它们转化为StaticSqlSource
StaticSqlSource中的Sql语句已经不包含#{} ${}，而是？，还有一个重要功能就是给出一个BoundSql对象
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163833.png)

#### 8.3、CacheRefResolver

> mybatis支持多个namespace之间共享缓存，使用cache-ref标签，可以声明另一个namespace
> 如下所示，代表的含义是UserDao可以使用TaskDao的缓存

CacheRefResolver就是用来处理多个命名空间共享缓存的问题
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163842.png)

#### 8.4、ResultMapResolver

> mybatis的resultMap标签允许继承，通过extends=xxxMap继承xxxMap设置的属性映射

![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163853.png)
ResultMapResolver就是用来解析resultMap的继承关系

#### 8.5、ParameterExpression（属性解析器）

> 用来将描述属性的字符串解析为键值对的形式

#### 8.6、xml

xml包中一共有5个解析器，负责将xml文件解析成对应的类，每个类解析的范围如下图

- XMLMapperEntityResolver
- XMLConfigBuilder
- XMLMapperBuilder
- XMLStatementBuilder
- XMLIncludeTransformer

![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163910.png)

##### 8.6.1、xml文件声明的解析

XML文件可以引用外部的DTD文件对XML文件进行校验，但是Mybatis有可能运行在无网络的环境中，无法联网下载DTD文件，针对于这种情况 XMLMapperEntityResolver就是解决这种问题的，在方法resolveEntity通过字符串匹配本地的DTD文件并返回

##### 8.6.2、配置文件的解析

配置文件的解析是由XMLConfigBuilder负责的，同时解析之后构建出一个Configuration对象
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163920.png)

##### 8.6.3、数据库操作语句解析

映射文件的解析由XMLMapperBuilder负责
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163938.png)
Q&A：
Q：解析过程中遇见循环依赖问题，Mybatis怎么解决的？比如解析xxxMapper中出现了extends属性，但是继承的属性还没有被解析，怎么办？
A:有两种解决方案
1、第一次全部解析，遇到错误先标记然后跳过，第二次只处理错误（Mybatis）
2、第一次解析只读如所有节点，但不处理依赖关系，然后在第二轮解析时只处理依赖关系（Spring）
Mybatis使用的第一种方式，Configuration中有一些属性转门记录临时性错误节点，在第二次解析时取出对应的属性值进行解析
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210163948.png)

##### 8.6.4、Statement解析

数据库操作节点（select、update、delete、insert）由XMLStatementBuilder完成

##### 8.6.5、引用解析

对于\\<\\include refid="">节点的解析是XMLIncludeTransformer负责的，能够将标签中的include节点替换为被引用的SQL片段
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164000.png)

##### 8.6.6、注解映射的解析

builder包中的annotation包就是用来解析注解配置映射
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164009.png)
开发过程中可以在映射接口中的抽象方法增加注解的方式来声明数据库操作
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164019.png)

### 9、mapping包（解析实体类）

mapping包主要完成了下列功能：

- SQL语句处理功能
- 输出结果处理功能
- 输入参数处理功能
- 多数据库种类处理功能
- 其他功能

#### 9.1、SQL语句处理功能

MappeddStatement：数据库操作节点（select、insert、）的所有内容
SqlSource：数据库操作标签包含的SQL语句
BoundSql：对于SqlSource的进一步处理
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164029.png)

#### 9.2、输出结果处理功能

Mybatis在映射文件的数据库操作节点中，可以使用ResultType把结果直接转换为java对象，另外一种更灵活的方式是使用ResultMap来定义输出结果的映射方式
ResultMap的功能十分强大，支持输出结果的组装、判断、懒加载，例如下面的代码例子就是根据sex的不同输出不同的子类
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164043.png)ResultMap标签的解析关系
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164054.png)

#### 9.3、输入参数处理功能

> 可以将对象映射成SQL语句需要的输入参数，使用parameterMap

代码示例：
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164104.png)
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164114.png)

#### 9.4、多数据库种类处理功能

> mybatis支持多种数据库，需要在配置文件中先列举需要使用的数据库类型

配置文件设置数据库：
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164124.png)
然后在SQL语句对应数据库类型
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164138.png)
**实现原理：**
多数据支持的实现由DatabaseIdProvider接口负责，有一个子类VendorDatabaseIdProvider，主要方法是setProperties和getDatabaseId
setProperties方法：将Mybatis配置文件中设置在databeseIdProvider节点中的信息写入VendorDatabaseIdProvider对象中
getDataBaseId方法：给出当前传入的datasource对象对应的databaseId，主要逻辑在getDatabaseName方法中
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164149.png)

### 10、scripting包

> SQL脚本中可以编写if、foreach、where等条件标签，这些标签的解析主要由scripting包完成的

#### 10.1、OGNL

> 是一种功能强大的表达式语言，通过它，能够完成从集合中选取对象、读写对象的属性、调用对象和类的方法、表达式求值和判断等操作
> OGNL有java工具包，只要引入就可以在java中使用OGNL功能

OGNL的三个重要概念：

- 表达式（expression）：是一个带语法含义的字符串，是整个OGNL的核心内容，通过表达式来确定需要进行的OGNL操作
- 根对象（root）：可以理解为OGNL的被操作对象，表达式中的操作就是针对这个对象展开的
- 上下文（context）：整个OGNL处理的上下文环境，是一个Map对象

#### 10.2、languageDriver

> 语言驱动类的接口，有两个默认实现，XMLLanguageDriver和RawLanguageDriver

![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164200.png)

#### 10.3、XMLScriptBuilder

> 映射文件中的语句有很多sql标签组成的一棵树，要想解析这颗树，首先需要将xml内容读取出来，然后在内存中构建SQL节点树，SQL节点树的构建由XMLScriptBuilder完成。

内部含有接口NodeHandle，每个SQL节点都有一个NodeHandle的实现，SQL节点和对应的Handle实现类的对应关系由nodeHandleMap维护
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164210.png)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164222.png)
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164232.png)

#### 10.4、xmltags

> SQL节点树的解析

OgnlClassResolver：DefaultClassResolver 类是 OGNL 中定义的一个类，OGNL 可以通过该类进行类的读取，即将类名转化为一个类
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164245.png)
OgnlMemberAccess:OGNL借助这个接口为访问的对象的属性做好准备
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164302.png)
OgnlCache：为了提升效率，做的一个缓存，对表达式进行预解析

#### 10.5、ExpressionEvaluator（表达式求值器）

> mybatis并没有把OGNL直接暴露给各个SQL节点使用，而是对OGNL进行更易用性的封装，对外暴露了ExpressionEvaluator类（表达式求值器）

提供了两个方法

- evaluateBoolean:能够对true或者false形式的表达式求值，例如if节点
- evaluateIterable:能够对结果是迭代形式的表达式进行求值，例如foreach

#### 10.6、DynamicContext（动态上下文）

> 一方面，在进行SQL树的解析时，需要不断的保存已经解析完成的SQL片段；
> 另一方面，在进行SQL节点树的解析时，也需要一些参数和环境信息，作为解析的依据
> 以上的两个功能就是由动态上下文来提供的

根据构造方法可以清楚的看出上下文环境是如何被创建出来的：
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164318.png)
上下文的bindings中存储了如下信息：

- 数据库id，因此在编写SQL语句时，我们可以直接使用DATABASE_ID_KEY引用数据库id的值
- 参数对象，在编写SQL语句时，可以直接使用PARAMETER_OBJECT_KEY变量来引用整个参数对象
- 参数对象的元数据，基于参数对象的元数据可以方便的引用参数对象的属性值，因此在编写SQL语句时可以直接引用参数对象的属性

#### 10.7、SqlNode

> SqlNode是一个接口，其中只定义了一个apply方法，该方法负责完成自身节点的解析，并将解析结果合并到输入参数提供的上下文环境中
> 编写的if where这些标签对应的就是一个SqlNode，分别对应IfSqlNode和WhereSqlNode

![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210171345.png)

### 11、datasource包（数据源）

#### 11.1、DataSourceFactory数据源工厂接口

> mybatis是根据datasource的type属性进行工厂的选择

![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164343.png)
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164356.png)

#### 11.2、JndiDataSourceFactory

> JNDI（Java Naming and Directory Interface）java命名和目录接口
> 能够为java程序提供命名和目录访问的接口，可以理解为一个命名规范，在使用该规范为资源命名并放入环境（context）中，我们可以根据名称从环境中查找（lookup）对应的资源
> JndiDataSourceFactory的作用就是从环境中找出指定的 JNDI数据源

在mybatis中使用JNDI：
![](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/20231210164421.png)

- initial_context:起始环境信息，Mybatis会在这里寻找指定的数据源，如果不设置，Mybatis会在整个环境中寻找数据源
- data_source:数据源名称

#### 11.3、UnpooledDataSourceFactory

> 非池化数据源工厂，需要真正的创建一个数据源，不过创建过程很简单，直接在构造方法中创建数据源对象，并保存在自身的成员变量中，

![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695259726942-4e7a2fda-5edd-4ec2-9ebf-d40a2467d146.png#averageHue=%23d8d8d8&clientId=u25fddd81-36ba-4&from=paste&height=312&id=u6242359c&originHeight=312&originWidth=1293&originalType=binary&ratio=1&rotation=0&showTitle=false&size=77722&status=done&style=shadow&taskId=u423ac0b5-b6b1-4039-bc91-94103122cd4&title=&width=1293)
非池化数据源是最简单的数据源，只需要在每次请求连接时打开连接，在每次连接结束时断开连接
在Mybatis中使用UNPOOLED来代表非池化数据源
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695260383744-0271fbe4-a678-40a2-aa02-b25eddd16a94.png#averageHue=%23d7d7d7&clientId=u25fddd81-36ba-4&from=paste&height=421&id=u067e3de0&originHeight=421&originWidth=763&originalType=binary&ratio=1&rotation=0&showTitle=false&size=190790&status=done&style=shadow&taskId=uc8aeebdf-8fd8-4170-9c6f-2f1abe30fee&title=&width=763)

#### 11.4、PooledDataSourceFactory

> 池化数据源，在连接池中总保留一定数量的数据库连接以备使用，可以在需要时取出，用完后放回，减少连接的创建和销毁工作，提升整体的效率

![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695260943847-e26d9006-2dd7-4093-891a-eaae3a7df26e.png#averageHue=%23d5d5d5&clientId=u25fddd81-36ba-4&from=paste&height=295&id=ub3c4357f&originHeight=295&originWidth=748&originalType=binary&ratio=1&rotation=0&showTitle=false&size=157146&status=done&style=shadow&taskId=u642d0907-d944-4165-bb53-bd8a1ed29b6&title=&width=748)
PooledDataSource：

- state：是一个PoolSate对象，存储了所有的数据库连接和状态信息，在类属性中，使用idleConnections和activeConnections两个列表存储了所有的空余连接和活跃连接，除此之外，还有大量的属性来存储连接池运行过程中的统计信息
- dataSource：当池化的数据源在连接池中的连接不够时，也需要创建新的连接，dataSource属性是一个UnPooledDataSource对象
- expectedConnectionTypeCode：一个数据源连接池必须确保池中的每个连接都是等价的，这样才能确保我们每次从连接池中取出连接不会存在差异。该属性存储的该数据源连接类型编码

#### 11.5、池化连接的给出和收回

- 给出池化连接：方法是popConnection，方法的伪代码总结如下图
  ![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695262191599-0717a764-99b5-41f6-90b4-123f420897f8.png#averageHue=%23dcdcdc&clientId=u25fddd81-36ba-4&from=paste&height=794&id=ub6b217ea&originHeight=794&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=157971&status=done&style=shadow&taskId=u052bee6c-3367-4aaf-bba7-397def8e2d3&title=&width=642)
- 收回池化连接，方法pushConnection
  ![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695262322730-77e29412-6605-4da4-ba4a-065314f0ed2f.png#averageHue=%23dbdbdb&clientId=u25fddd81-36ba-4&from=paste&height=374&id=u0d6106ab&originHeight=374&originWidth=734&originalType=binary&ratio=1&rotation=0&showTitle=false&size=97559&status=done&style=shadow&taskId=ue1cf1a13-aa1d-4ed5-aa4a-5560d44fa78&title=&width=734)

#### 11.6、PooledConnection

池化连接，当我们要关闭一个池化连接时，它不应该真正的被关掉，而是应该将自己放回连接池，所以，通过PooledDataSource获取的数据库连接，不能是普通的Connection对象
pooled子包中存在一个PooledConnection对象，是对普通Connection对象的代理，其中一个重要工作就是修改Connection类的close方法的行为
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695262785375-55a241e2-d348-431a-93c4-6d1230a575bc.png#averageHue=%232c2c2b&clientId=u25fddd81-36ba-4&from=paste&height=724&id=ub0288d98&originHeight=724&originWidth=990&originalType=binary&ratio=1&rotation=0&showTitle=false&size=90445&status=done&style=shadow&taskId=ud167382a-ae86-4dec-a765-0aea22519e4&title=&width=990)

### 12、jdbc包

> 该包提供了数据库操作语句的能力和脚本运行能力

#### 12.1、AbstractSQL

> 抽象类，含有一个抽象方法getSelf
> 包含两个静态内部类SafeAppendable 、 SQLStatement

SafeAppendable：
是一个拼接器，append方法能实现串的拼接功能
SQLStatement：
可以完整的表述出一条SQL语句

#### 12.2、SqlRunner

> 可以直接执行SQL语句的工具类
> SqlRunner可以接受SQL语句和参数，然后执行数据库操作，不过并不能完成对象和SQL参数、结果等的对象映射

![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695264760409-d50e9339-67aa-474f-be1b-befded380d77.png#averageHue=%23d8d8d8&clientId=u25fddd81-36ba-4&from=paste&height=313&id=udadc28f2&originHeight=313&originWidth=754&originalType=binary&ratio=1&rotation=0&showTitle=false&size=124777&status=done&style=shadow&taskId=u48acc6f7-2f12-467e-a623-859483e108c&title=&width=754)

#### 12.3、ScriptRunner

> 可以直接执行脚本的工具类，开发者可以直接把整个脚本文件交给Mybatis执行

![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695265424817-fc3141a5-a9e2-466a-b1e2-2d8bead407c6.png#averageHue=%23d1d1d1&clientId=u25fddd81-36ba-4&from=paste&height=159&id=u579e3ecc&originHeight=159&originWidth=1318&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66007&status=done&style=shadow&taskId=ub022f5e6-8e10-4657-8ebb-98e0387fd3b&title=&width=1318)

### 13、cache包

> cache包是典型的装饰器模式的应用案例，在imple子包存放了实现类，在decorators子包中存放了众多装饰器类，而cache接口是实现类和装饰器类的共同接口

![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695284644602-131bbf9b-7bf0-4ec4-bde7-69672078acb1.png#averageHue=%23f2f2f2&clientId=u25fddd81-36ba-4&from=paste&height=590&id=u7d969345&originHeight=590&originWidth=785&originalType=binary&ratio=1&rotation=0&showTitle=false&size=142328&status=done&style=shadow&taskId=u860d74f5-2623-4b70-abbf-3b68d1f3b6f&title=&width=785)

#### 13.1、CacheKey缓存键

> Mybatis每秒过滤众多的数据库查询操作，这对Mybatis缓存键的设计提出了很高的要求，必须满足一下几点

- 无碰撞：必须保证两个不同的查询请求生成的键不一致，
- 高效比较：每次缓存查询操作都可能会引发键之间的多次比较，因此该操作必须是高效的
- 高效生成：每次缓存查询和写入操作都需要生成缓存的键，因此该操作也必须是高效的

缓存键的生成：
在数据库查询时，会根据当前的查询条件生成一个CacheKey，在BaseExecutor中可以看到这个过程
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695286620942-0eee6e1c-1b2b-44f5-820e-9ca6ebd8adf3.png#averageHue=%23d5d5d5&clientId=u25fddd81-36ba-4&from=paste&height=203&id=uee256ee6&originHeight=203&originWidth=794&originalType=binary&ratio=1&rotation=0&showTitle=false&size=105790&status=done&style=shadow&taskId=uf325a95f-7fec-4525-a6d9-b0c3be12777&title=&width=794)

#### 13.2、PerpetualCache

> 缓存的实现类，只有两个属性
> id：用来标识一个缓存，一般使用映射文件的namespace作为缓存的id，这样能保证不同的映射文件的缓存是不同的
> cache：是一个hashMap，采用键值对的形式来存储数据

#### 13.3、缓存装饰器

> decorators包下存在很多的装饰器，根据装饰器的功能可以将他们分为几个大类

- 同步装饰器：为缓存增加同步功能 如SynchronizedCache
- 日志装饰器：为缓存增加日志功能 如LoggingCache
- 清理装饰器：为缓存中的数据增加清理功能，如FifoCache，LruCache
- 阻塞装饰器：为缓存增加阻塞功能，如BlockingCache
- 定时清理装饰器：为缓存增加定时刷新功能，如ScheduledCache
- 序列化装饰器：为缓存增加序列化功能，如SerializedCache
- 事务装饰器：用于支持事务操作的装饰器，如TransactionCache

##### 13.3.1、同步装饰器

在Mybatis使用过程中，可能会出现多个线程同时访问一个缓存的情况，例如下图代码所示，如果多个线程同时调用selectUsers方法，而缓存实现类PerpetualCache并没有增加任何多线程的保护措施，会引发线程安全问题，而Mybatis将这项工作交给了SynchronizedCache，它的实现非常简单，在被包装的对象方法外围增加Synchronized关键字，使得方法编程同步方法
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695293324472-3d42136f-e49b-4324-8943-d97dd537f65d.png#averageHue=%23d8d8d8&clientId=u25fddd81-36ba-4&from=paste&height=317&id=u32b666b1&originHeight=317&originWidth=1364&originalType=binary&ratio=1&rotation=0&showTitle=false&size=71687&status=done&style=shadow&taskId=u65f7b281-f7d6-4775-985e-ff581abba66&title=&width=1364)

##### 13.3.2、日志装饰器

为数据库操作增加缓存的目的是减少数据库的查询操作从而提高运行效率。而缓存的配置也非常重要，如果配置过大则浪费内存空间，如果配置过小则无法更好地发挥作用。因此，需要依据一些运行指标来设置合适的缓存大小。
日志装饰器可以为缓存增加日志统计的功能，而需要统计的数据主要是缓存命中率。所谓缓存命中率是指在多次访问缓存的过程中，能够在缓存中查询到数据的比率。
日志装饰器的实现非常简单，即在缓存查询时记录查询的总次数与命中次数
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695293608142-f9f258c2-e476-42bc-a77d-0829956d99e2.png#averageHue=%232c2b2b&clientId=u25fddd81-36ba-4&from=paste&height=514&id=u2846e4d2&originHeight=514&originWidth=783&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49626&status=done&style=shadow&taskId=ue3f6be89-8d49-4bd6-b315-a8947d75c96&title=&width=783)

##### 13.3.3、清理装饰器

虽然缓存能够极大地提升数据查询的效率，但这是以消耗内存空间为代价的。
缓存空间总是有限的，因此为缓存增加合适的清理策略以最大化地利用这些缓存空间十分重要。
缓存装饰器中有四种清理装饰器可以完成缓存清理功能，这四种清理装饰器也对应了MyBatis的四种缓存清理策略

- FifoCache装饰器：采用先进先出的策略来清理缓存，它内部使用了 keyList属性存储了缓存数据的写入顺序，并且使用 size属性存储了缓存数据的数量限制。当缓存中的数据达到限制时，FifoCache装饰器会将最先放入缓存中的数据删除
- LruCache装饰器：即近期最少使用算法，该算法会在缓存数据数量达到设置的上限时将近期未使用的数据删除。LruCache 装饰器便可以为缓存增加这些功能
- WeakCache装饰器：通过将缓存数据包装成弱引用的数据，从而使得 JVM可以清理掉缓存数据
- SoftCache装饰器：SoftCache 装饰器和 WeakCache 装饰器在结构、功能上高度一致，只是从弱引用变成了软引用

##### 13.3.4、阻塞装饰器

当 MyBatis 接收到一条数据库查询请求，而对应的查询结果在缓存中不存在时，MyBatis会通过数据库进行查询。试想如果在数据库查询尚未结束时，MyBatis又收到一条完全相同的数据库查询请求，那应该怎样处理呢？常见的有以下两种方案。

-  因为缓存中没有对应的缓存结果，因此再发起一条数据库查询请求，这会导致数据库短时间内收到两条完全相同的查询请求。· 
-  虽然缓存中没有对应的缓存结果，但是已经向数据库发起过一次请求，因此缓存应该先阻塞住第二次查询请求。等待数据库查询结束后，将数据库的查询结果返回给两次查询请求即可。

显然，后一种方案更为合理。阻塞装饰器 BlockingCache 为缓存提供了上述功能
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695293836197-20cd5cc1-9045-497c-81c7-6a3d0e444018.png#averageHue=%23f2f2f2&clientId=u25fddd81-36ba-4&from=paste&height=561&id=u3da0e6b8&originHeight=561&originWidth=1218&originalType=binary&ratio=1&rotation=0&showTitle=false&size=69622&status=done&style=shadow&taskId=u743d8522-8646-4c1d-919e-7f914c82d12&title=&width=1218)

##### 13.3.5、定时清理装饰器

当调用缓存的 clear方法时，会清理缓存中的数据。但是该操作不会自动执行。
定时清理装饰器 ScheduledCache则可以按照一定的时间间隔来清理缓存中的数据，即按照一定的时间间隔调用 clear方法

##### 13.3.6、序列化装饰器

有些场景下，我们不想让外部的引用污染缓存中的对象。这时必须保证外部读取缓存中的对象时，每次读取的都是一个全新的拷贝而不是引用。
序列化装饰器SerializedCache为缓存增加了这一功能。在使用 SerializedCache后，每次向缓存中写入对象时，实际写入的是对象的序列化串；而每次读取对象时，会将序列化串反序列化后再返回。
通过序列化和反序列化的过程保证了每一次缓存给出的对象都是一个全新的对象，对该对象的修改不会影响缓存中的对象。
当然，这要求被缓存的数据必须是可序列化的，否则SerializedCache会抛出异常

#### 13.4、缓存的组建

组建缓存的过程就是根据需求为缓存的基本实现增加各种装饰的过程，该过程在CacheBuilder中完成
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695294080115-e9a51bcf-5c77-4cd2-9efb-1e8e48136665.png#averageHue=%232d2c2c&clientId=u25fddd81-36ba-4&from=paste&height=731&id=u7a5f5aa3&originHeight=731&originWidth=993&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75782&status=done&style=shadow&taskId=ubed6f82f-e203-4b1e-9029-7e4d09d8906&title=&width=993)
在映射文件中，我们可以通过如下所示的片段指定缓存的特性
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695294178724-70e67500-2287-428b-b757-c1da382f5d40.png#averageHue=%23dadada&clientId=u25fddd81-36ba-4&from=paste&height=431&id=u7e6b5977&originHeight=431&originWidth=1464&originalType=binary&ratio=1&rotation=0&showTitle=false&size=99362&status=done&style=shadow&taskId=u949eb5bf-ddb2-40d1-9514-0a2e2b2804a&title=&width=1464)

#### 13.5、事务缓存

在数据库操作中，如果没有显式地声明事务，则一条语句本身就是一个事务。在查询语句进行数据库查询操作之后，相应的查询结果可以立刻放入缓存中备用。
那么，事务中的语句进行数据库查询操作之后，相应的查询结果可以立刻放入缓存备用吗？显然不可以。例如下图 所示的事务操作中，SELECT 操作得到的查询结果中其实包含了前面 INSERT语句插入的信息。如果 SELECT查询结束后立刻将查询结果放入缓存，则在事务提交前缓存中就包含了事务中的信息，这是违背事务定义的。而如果之后该事务进行了回滚，则缓存中的数据就会和数据库中的数据不一致。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695294313593-7739d7fd-a89e-4263-9ea5-ba1d5cb53bee.png#averageHue=%23d7d7d7&clientId=u25fddd81-36ba-4&from=paste&height=253&id=udaf898fd&originHeight=253&originWidth=1653&originalType=binary&ratio=1&rotation=0&showTitle=false&size=78642&status=done&style=shadow&taskId=u1970ce98-64aa-45ca-aaf8-54a3eba31df&title=&width=1653)
因此，事务操作中产生的数据需要在事务提交时写入缓存，而在事务回滚时直接销毁。TransactionalCache装饰器就为缓存提供了这一功能。
它使用entriesToAddOnCommit属性将事务中产生的数据暂时保存起来，在事务提交时一并提交给缓存，而在事务回滚时直接销毁。
TransactionalCache类也支持将缓存的范围限制在事务以内，只要将clearOnCommit属性置为 true即可。这样，只要事务结束，就会直接将暂时保存的数据销毁掉，而不是写入缓存中。

### 14、MyBatis缓存机制

#### 14.1、一级缓存

MyBatis 的一级缓存又叫本地缓存，其结构和使用都比较简单，与它相关的配置项有两个。

- 是在配置文件的 settings节点下，我们可以增加如下图所示的配置语句来改变一级缓存的作用范围。配置值的可选项有 SESSION与 STATEMENT，分别对应了一次会话和一条语句。一级缓存的默认作用范围是 SESSION
  ![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695294715408-0fd8baea-f429-456a-8619-941b969d3e39.png#averageHue=%23cbcbcb&clientId=u25fddd81-36ba-4&from=paste&height=49&id=DlV2n&originHeight=49&originWidth=1070&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22611&status=done&style=shadow&taskId=u1c76ef16-53b3-4a1a-ab2c-c0adad79cf9&title=&width=1070)
- 可以在映射文件的数据库操作节点内增加 flushCache属性项，如下图所示，该属性可以设置为 true或 false。当设置为 true时，MyBatis会在该数据库操作执行前清空一、二级缓存。该属性的默认值为 false
  ![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695294676766-04fd545b-7666-47af-b280-353fd3c5f222.png#averageHue=%23d0d0d0&clientId=u25fddd81-36ba-4&from=paste&height=151&id=u189c4af7&originHeight=151&originWidth=1262&originalType=binary&ratio=1&rotation=0&showTitle=false&size=59277&status=done&style=shadow&taskId=u442ba93b-ad5f-4e12-a0dd-9d53bb8d531&title=&width=1262)

一级缓存源码实现：
一级缓存功能由 BaseExecutor类实现。
BaseExecutor类作为实际执行器的基类，为所有实际执行器提供一些通用的基本功能，在这里增加缓存也就意味着每个实际执行器都具有这一级缓存
在 BaseExecutor 内，可以看到与一级缓存相关的两个属性，分别是 localCache 和localOutputParameterCache，如下图所示。这两个属性使用的都是没有经过任何装饰器装饰的 PerpetualCache对象
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695294880830-7662db3d-2a90-4708-9b7b-fc7f0e0554d9.png#averageHue=%23d3d3d3&clientId=u25fddd81-36ba-4&from=paste&height=211&id=u452bcd9b&originHeight=211&originWidth=1201&originalType=binary&ratio=1&rotation=0&showTitle=false&size=71252&status=done&style=shadow&taskId=u3458d69c-f704-42fc-b0ff-4f349b96ba3&title=&width=1201)
这两个变量中，localCache缓存的是数据库查询操作的结果。对于CALLABLE形式的语句，因为最终向上返回的是输出参数，便使用 localOutputParameterCache 直接缓存的输出参数。
因为 localCache 和 localOutputParameterCache 都是 Executor 的属性，不可能超出Executor 的作用范围。而 Executor 归属 SqlSession，因此第一级缓存的最大作用范围便是SqlSession，即一次会话。

#### 14.2、二级缓存

二级缓存的作用范围是一个命名空间（即一个映射文件），而且可以实现多个命名空间共享一个缓存。因此与一级缓存相比其作用范围更广，且选择更为灵活。
与二级缓存相关的配置项有四项

- 配置项在配置文件的 settings节点下，我们可以增加如下所示的配置语句来启用和关闭二级缓存。该配置项的默认值为 true，即默认启用二级缓存
  ![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695295049058-7454498e-1447-491d-a7c5-f0b648d809b7.png#averageHue=%23d2d2d2&clientId=u25fddd81-36ba-4&from=paste&height=51&id=ubbcb5ed0&originHeight=51&originWidth=1121&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17734&status=done&style=shadow&taskId=u97b21e67-6b93-4cf7-a731-1cd3ac7309a&title=&width=1121)
- 第二个配置项在映射文件内。可以使用如下所示的 cache标签来开启并配置本命名空间的缓存，也可以使用如下 所示的标签来声明本命名空间使用其他命名空间的缓存，如果两项都不配置则表示命名空间没有缓存。该项配置只有在第一项配置中选择启用二级缓存时才有效
  ![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695294178724-70e67500-2287-428b-b757-c1da382f5d40.png#averageHue=%23dadada&clientId=u25fddd81-36ba-4&from=paste&height=431&id=eJCA1&originHeight=431&originWidth=1464&originalType=binary&ratio=1&rotation=0&showTitle=false&size=99362&status=done&style=shadow&taskId=u949eb5bf-ddb2-40d1-9514-0a2e2b2804a&title=&width=1464)
  ![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695295147279-631b812f-4f34-4642-bbfb-1fe6bc87066a.png#averageHue=%23c5c5c5&clientId=u25fddd81-36ba-4&from=paste&height=47&id=u6ed86b47&originHeight=47&originWidth=1257&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30315&status=done&style=shadow&taskId=u27271d0d-57b4-42d9-8111-b4f0db45b56&title=&width=1257)
- 数据库操作节点内的 useCache属性，如下所示。通过它可以配置该数据库操作节点是否使用二级缓存。只有当第一、二项配置均启用了缓存时，该项配置才有效。对于 SELECT类型的语句而言，useCache属性的默认值为 true，对于其他类型的语句而言则没有意义
  ![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695295189503-7f23c22c-d9b9-4d40-a2da-ca09356ece21.png#averageHue=%23d2d2d2&clientId=u25fddd81-36ba-4&from=paste&height=163&id=u84d68818&originHeight=163&originWidth=1502&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65142&status=done&style=shadow&taskId=u165c2847-d558-4b25-8da7-8320e11bdb9&title=&width=1502)
- 数据库操作节点内的 flushCache 属性项，该配置属性与一级缓存共用，表示是否要在该语句执行前清除一、二级缓存

二级缓存源码实现：
二级缓存功能由 CachingExecutor类实现，它是一个装饰器类，能通过装饰实际执行器为它们增加二级缓存功能。如下所示，在 Configuration的newExecutor方法中，MyBatis会根据配置文件中的二级缓存开关配置用CachingExecutor类装饰实际执行器
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695295304922-a90556a6-20e9-4b65-81b7-275c27328753.png#averageHue=%23d7d7d7&clientId=u25fddd81-36ba-4&from=paste&height=575&id=u40dd7a8d&originHeight=575&originWidth=765&originalType=binary&ratio=1&rotation=0&showTitle=false&size=258967&status=done&style=shadow&taskId=u1b07ebac-84c0-4328-9820-be157eaf629&title=&width=765)

#### 14.3、两级缓存机制

现在我们已经清楚 MyBatis 存在两级缓存，其中一级缓存由 BaseExecutor 通过两个PerpetualCache类型的属性提供，而二级缓存由 CachingExecutor包装类提供。
那么在数据库查询操作中，是先访问一级缓存还是先访问二级缓存呢？
答案并不复杂，CachingExecutor作为装饰器会先运行，然后才会调用实际执行器，这时 BaseExecutor 中的方法才会执行。因此，在数据库查询操作中，MyBatis 会先访问二级缓存再访问一级缓存
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695295400345-aa92e788-f0ed-49ff-8b07-ef25d7eba941.png#averageHue=%23f5f5f5&clientId=u25fddd81-36ba-4&from=paste&height=708&id=uc62a9f4e&originHeight=708&originWidth=768&originalType=binary&ratio=1&rotation=0&showTitle=false&size=153177&status=done&style=shadow&taskId=u9595b315-954a-4f04-9783-a49dc849830&title=&width=768)

### 15、transaction包

> 负责进行事务管理的包，该包内包含两个子包：
> jdbc子包中包含基于 JDBC进行事务管理的类
> managed子包中包含基于容器进行事务管理的类

整个transaction包使用工厂模式实现
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695366772278-dd707af8-5248-4e02-9f06-17bc225ec343.png#averageHue=%23f1f1f1&clientId=u5f7f2a1e-1920-4&from=paste&height=442&id=u35d79c4b&originHeight=442&originWidth=1683&originalType=binary&ratio=1&rotation=0&showTitle=false&size=98166&status=done&style=shadow&taskId=u9172e32f-a712-45af-9dd8-fc704c10e07&title=&width=1683)
TransactionFactory 是所有事务工厂的接口
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695366958411-9c430ac8-fc7d-4d39-898c-fad87482d90d.png#averageHue=%233d4043&clientId=u5f7f2a1e-1920-4&from=paste&height=97&id=u551175c0&originHeight=97&originWidth=629&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7604&status=done&style=shadow&taskId=u61a1cb5e-612c-4a1c-b020-67f9af2094a&title=&width=629)
Transaction 是所有事务的接口
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695366942204-e4e7106e-004d-45a5-b94f-ea9ba130c34e.png#averageHue=%233c4043&clientId=u5f7f2a1e-1920-4&from=paste&height=139&id=uaa4de14e&originHeight=139&originWidth=403&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5122&status=done&style=shadow&taskId=u8f1ebbc9-d4f2-4584-8d2e-52e4dad31d1&title=&width=403)

#### 15.1、jdbc事务

jdbc子包中存放的是实现 JDBC事务的 JdbcTransaction类及其对应的工厂类。
JdbcTransaction类是 JDBC事务的管理类
而具体的事务操作是由 JdbcTransaction类直接调用 Connection类提供的事务操作方法来完成的

#### 15.2、容器事务

managed子包中存放的是实现容器事务的 ManagedTransaction类及其对应的工厂类。
在 ManagedTransaction类中，可以看到 commit、rollback等方法内都没有任何逻辑操作
那么这些方法是空的，又如何实现事务管理呢？
这是因为相关的事务操作都委托给了容器进行管理。以 Spring容器为例。当 MyBatis和 Spring集成时，MyBatis中拿到的数据库连接对象是 Spring给出的。Spring可以通过 XML配置、注解等多种方式来管理事务（即决定事务何时开启、回滚、提交）。
当然，这种情况下，事务的最终实现也是通过 Connection对象的相关方法进行的。
整个过程中，MyBatis 不需要处理任何事务操作，全都委托给 Spring即可

### 16、cursor包（游标）

> 使用场景：
> 在使用 MyBatis进行数据库查询时，经常会查询到大量的结果。在代码21-3所示的例子中，我们查询到了大量的 User对象，并使用 List接受这些对象
> ![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695368235878-700e38b6-3795-4cc1-8d17-bda2979d6c61.png#averageHue=%23c3c3c3&clientId=u5f7f2a1e-1920-4&from=paste&height=43&id=uc2c93533&originHeight=43&originWidth=1182&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27283&status=done&style=shadow&taskId=ubc4d02b8-4cb8-4d13-8e0d-c31c9b934a0&title=&width=1182)
> 但有些时候，我们希望逐一读入和处理查询结果，而不是一次读入整个结果集。因为前者能够减少对内存的占用，这在处理大量的数据时会显得十分必要。
> 游标就能够帮助我们实现这一目的，它支持我们每次从结果集中取出一条结果。
> 在 MyBatis中使用游标进行查询非常简单，映射文件不需要任何的变动，只需要在映射接口中标明返回值类型是 Cursor即可

![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695368289384-6e2ad1e1-d0dc-48d7-8cec-642623d94109.png#averageHue=%23cdcdcd&clientId=u5f7f2a1e-1920-4&from=paste&height=51&id=u6d986941&originHeight=51&originWidth=1010&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21217&status=done&style=shadow&taskId=uea707faf-5910-48b8-aac2-2be9daafed9&title=&width=1010)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695368307517-625050b6-1b12-472a-b388-efad4cc31183.png#averageHue=%23d5d5d5&clientId=u5f7f2a1e-1920-4&from=paste&height=177&id=u47d98f86&originHeight=177&originWidth=778&originalType=binary&ratio=1&rotation=0&showTitle=false&size=91585&status=done&style=shadow&taskId=u310ca921-2d46-48fa-8ce9-a3427129f12&title=&width=778)

### 17、executor包

> 如果从 MyBatis的所有包中选择一个最为重要的包，那就是 executor包。
> executor 包，顾名思义为执行器包，它作为 MyBatis 的核心将其他各个包凝聚在了一起。
> 在该包的工作中，会调用配置解析包解析出的配置信息，会依赖基础包中提供的基础功能。最终，executor包将所有的操作串接在了一起，通过 session包向外暴露出一套完整的服务。

#### 17.1、主键自增

> 许多数据库都支持主键自增功能，如 MySQL数据库、SQL Server数据库等。当然也有一些数据库不支持主键自增功能，如 Oracle数据库。MyBatis的 executor包中的 keygen子包兼容以上这两种情况

![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695370221164-54898fcd-9358-4240-9cec-47c6eb4a53d7.png#averageHue=%23f3f3f3&clientId=u5f7f2a1e-1920-4&from=paste&height=399&id=udaa51c36&originHeight=399&originWidth=1486&originalType=binary&ratio=1&rotation=0&showTitle=false&size=60166&status=done&style=shadow&taskId=u080e3a8f-3056-4a5d-a111-bc46e53e45a&title=&width=1486)
配置与生效：

- 要启动Jdbc3KeyGenerator，可以配置文件中增加setting属性或者直接在相关语句中启用
  ![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695370291597-d38700b4-b461-49f6-a667-ff573c503dec.png#averageHue=%23d0d0d0&clientId=u5f7f2a1e-1920-4&from=paste&height=55&id=uc18ce755&originHeight=55&originWidth=902&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19346&status=done&style=shadow&taskId=ub851f89d-53c0-48c3-a38c-715196009fb&title=&width=902)
  ![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695370341619-b81aa915-d478-496a-a09b-a50d05406789.png#averageHue=%23d7d7d7&clientId=u5f7f2a1e-1920-4&from=paste&height=316&id=u03ed2ca9&originHeight=316&originWidth=1510&originalType=binary&ratio=1&rotation=0&showTitle=false&size=89507&status=done&style=shadow&taskId=u812e9666-cb2d-4a80-93c0-93b52d2e8c5&title=&width=1510)
- 要启用 SelectKeyGenerator，则需要在 SQL语句前加一段 selectKey标签
  ![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695370363811-5f0426fb-0edf-409b-bc14-0bf55d0e1389.png#averageHue=%23d9d9d9&clientId=u5f7f2a1e-1920-4&from=paste&height=235&id=u81636e6e&originHeight=235&originWidth=769&originalType=binary&ratio=1&rotation=0&showTitle=false&size=91701&status=done&style=shadow&taskId=u73bb30ce-7481-4297-a956-b6256a3e9cb&title=&width=769)

如果两个都配置了，则以后者（SelectKeyGenerator）为主

#### 17.2、Jdbc3KeyGenerator类

> Jdbc3KeyGenerator类是为具有主键自增功能的数据库准备的
> 既然数据库已经支持主键自增了，那 Jdbc3KeyGenerator类存在的意义是什么呢？
> 它存在的意义是提供自增主键的回写功能

#### 17.3、SelectKeyGenerator类

> 可以真正地生成自增的主键
> SelectKeyGenerator类实现了 processBefore和 processAfter这两个方法

#### 17.4、懒加载

![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695370877569-a0162915-f358-4c8e-9ec0-cb941df97053.png#averageHue=%23d6d6d6&clientId=u5f7f2a1e-1920-4&from=paste&height=317&id=uca3f715c&originHeight=317&originWidth=1384&originalType=binary&ratio=1&rotation=0&showTitle=false&size=104853&status=done&style=shadow&taskId=udb3bbae1-f2d0-4e65-948a-0544626e5fa&title=&width=1384)
aggressiveLazyLoading 是激进懒加载设置，我们对该属性进行一些说明。当aggressiveLazyLoading设置为 true时，对对象任一属性的读或写操作都会触发该对象所有懒加载属性的加载；当 aggressiveLazyLoading设置为 false时，对对象某一懒加载属性的读操作会触发该属性的加载。无论 aggressiveLazyLoading的设置如何，调用对象的“equals”“clone”“hashCode”“toString”中任意一个方法都会触发该对象所有懒加载属性的加载
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695370963772-42d827bd-dee1-47c8-a0f6-9954ea7ced7a.png#averageHue=%23d6d6d6&clientId=u5f7f2a1e-1920-4&from=paste&height=260&id=u4dce8b75&originHeight=260&originWidth=797&originalType=binary&ratio=1&rotation=0&showTitle=false&size=128653&status=done&style=shadow&taskId=u9791832c-8a83-41aa-b3f5-3815e4a747b&title=&width=797)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695370974478-e4625392-b4f7-440a-8224-f97c9ef51aca.png#averageHue=%23d7d7d7&clientId=u5f7f2a1e-1920-4&from=paste&height=372&id=u033826b0&originHeight=372&originWidth=1305&originalType=binary&ratio=1&rotation=0&showTitle=false&size=89730&status=done&style=shadow&taskId=ue3a3373b-63c9-4751-b874-574a5fd85e4&title=&width=1305)
功能实现：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695371244228-667995de-bc13-4cb7-a1ad-be9f0abd4713.png#averageHue=%23f3f3f3&clientId=u5f7f2a1e-1920-4&from=paste&height=745&id=u033ca9de&originHeight=745&originWidth=792&originalType=binary&ratio=1&rotation=0&showTitle=false&size=165728&status=done&style=shadow&taskId=u089ad058-5992-48f8-8263-ab65ed9e132&title=&width=792)

#### 17.5、语句处理功能

在 MyBatis映射文件的编写中，我们常会见到“${}”和“＃{}”这两种定义变量的符号，其含义如下

- ${}：使用这种符号的变量将会以字符串的形式直接插到 SQL片段中。
- ＃{}：使用这种符号的变量将会以预编译的形式赋值到 SQL片段中。

MyBatis中支持三种语句类型，不同语句类型支持的变量符号不同。MyBatis中的三种语句类型如下

- STATEMENT：这种语句类型中，只会对 SQL片段进行简单的字符串拼接。因此，只支持使用“${}”定义变量
- PREPARED：这种语句类型中，会先对 SQL片段进行字符串拼接，然后对 SQL片段进行赋值。因此，支持使用“${}”“＃{}”这两种形式定义变量
- CALLABLE：这种语句类型用来实现执行过程的调用，会先对 SQL 片段进行字符串拼接，然后对 SQL片段进行赋值。因此，支持使用“${}”“＃{}”这两种形式定义变量

在创建 SQL语句时，语句的类型由 statementType 属性进行指定。如果不指定则默认采用 PREPARED 
在对CALLABLE语句进行调用时，可以直接使用Map来设置输入参数。使用MyBatis调用存储过程的操作如下图所示：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695371888093-967da410-321e-434b-801b-d3cca9e166a5.png#averageHue=%23d9d9d9&clientId=u5f7f2a1e-1920-4&from=paste&height=285&id=uf32cb77e&originHeight=285&originWidth=795&originalType=binary&ratio=1&rotation=0&showTitle=false&size=106252&status=done&style=shadow&taskId=uc593f3dd-950b-4592-9956-95ac5db44dc&title=&width=795)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695371850890-e112c3c7-4090-410f-ba0c-2b323228d9b0.png#averageHue=%23d4d4d4&clientId=u5f7f2a1e-1920-4&from=paste&height=285&id=u77f0c249&originHeight=285&originWidth=1518&originalType=binary&ratio=1&rotation=0&showTitle=false&size=105367&status=done&style=shadow&taskId=uca5b5981-36fa-4031-92b1-27e23a7fce7&title=&width=1518)

### 18、session包

![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695372141481-a8a8be17-2bff-49a1-8e6a-4b5ea70f5aae.png#averageHue=%23eeeeee&clientId=u5f7f2a1e-1920-4&from=paste&height=380&id=uaa69a44e&originHeight=380&originWidth=1592&originalType=binary&ratio=1&rotation=0&showTitle=false&size=91018&status=done&style=shadow&taskId=uffa4d798-7858-432f-af09-ac3cd6a7f01&title=&width=1592)

#### 18.1、DefaultSqlSession类

session包是整个 MyBatis应用的对外接口包，而 executor包是最为核心的执行器包。
DefaultSqlSession 类做的主要工作则非常简单——把接口包的工作交给执行器包处理
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695372251412-fddb7b81-221e-49d4-b9a1-d18deecb3c93.png#averageHue=%23d8d8d8&clientId=u5f7f2a1e-1920-4&from=paste&height=338&id=u620cb501&originHeight=338&originWidth=795&originalType=binary&ratio=1&rotation=0&showTitle=false&size=138426&status=done&style=shadow&taskId=u29fcbc7b-f22f-41e6-b348-6050f38127d&title=&width=795)

#### 18.2、SqlSessionManager类

![image.png](https://cdn.nlark.com/yuque/0/2023/png/34733797/1695372281886-12ad4418-68b5-418d-8644-886be4bee5ef.png#averageHue=%23f3f3f3&clientId=u5f7f2a1e-1920-4&from=paste&height=630&id=u2239d47a&originHeight=630&originWidth=965&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66042&status=done&style=shadow&taskId=u71b9e6bc-70bc-4be0-8ce5-9c3514d86d7&title=&width=965)

### 19、plugin包

