---
title: JDK源码中有趣的位运算
date: 2023-12-08 09:13:16
permalink: /be/935100/
categories:
  - 源码
tags:
  - 位运算
author: 
  name: zhaoyb
  link: https://github.com/zhaoyb-coder
---

# JDK源码中有趣的位运算

> 本文全篇分析基于JDK1.8源码

## 1、ReentrantReadWriteLock中的位运算

### 1.1、前提分析

在ReentrantReadWriteLock源码上面有这样一段注释：

> This lock supports a maximum of 65535 recursive write locks and 65535 read locks. Attempts to exceed these limits result in Error throws from locking methods.

为什么最大只支持65535个递归写锁和读锁呢？65535 = 2^{16} - 1    `源码之下无秘密`

首先，我们需要知道ReentrantReadWriteLock的加锁原理，标识当前资源是否已经加锁，使用的是AQS内部的int类型的变量state来标识。

对于可重入锁ReentrantLock来说，标识加锁很简单，判断 state=0 或者 state>0就可以了，只要state>0，那就代表当前资源处于锁定状态，但是对于ReentrantReadWriteLock来说，加锁有两种状态，读锁和写锁，读锁可以共享，写锁代表互斥，那一个state变量怎么来标识两种锁的状态呢？

先复习一下基础知识：int类型占用4个字节(byte)，一个字节占用8位(比特bite)，也就是说一个int类型的变量在操纵系统看来一共占用32位，也就是32个0或者1的组合，举例如下：

int i = 1;  那 i 在操作系统看来就是  0000000000000000000000000000001

int i = 2;  那 i 在操作系统看来就是  0000000000000000000000000000010

为了解决一个state变量来标识两个锁的状态，JDK开发人员，把state的32位分为了高16位和低16位，其中如果加了读锁，那就是在高16位上面进行位运算；如果是加了写锁，那就在state的低16位上面进行位运算

![image-20231208104337829](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20231208104337829.png)

### 1.2、源码分析

具体在源码中看一下加锁和解锁的各种写法

```java
ReentrantReadWriteLock rw = new ReentrantReadWriteLock();
ReentrantReadWriteLock.ReadLock r = rw.readLock();
ReentrantReadWriteLock.WriteLock w = rw.writeLock();
//读锁 加锁
r.lock();
//读锁 解锁
r.unlock();
//写锁 加锁
w.lock();
//写锁 解锁
w.unlock();
```

------

#### 1.2.1、读锁 加锁

读锁加锁会直接调用sync.acquireShared(1)方法，其中Sync是ReentrantReadWriteLock中基于AQS的实现的一个同步器

其中Sync内部有比较重要的四个属性，两个方法，如下代码所示

```java
// 读取与写入计数提取常量和函数
// 锁状态在逻辑上分为两个无符号短整型：下部表示独占（写入器）锁定保持计数，上部表示共享（读取器）保持计数
static final int SHARED_SHIFT   = 16;
// 1 << 16 代表1左位移16，也就是 00000000 00000001 00000000 00000000  也就是所谓的高16位的开始
static final int SHARED_UNIT    = (1 << SHARED_SHIFT);
// 1 << 16 -1 代表1左位移16再减去1，也就是 00000000 00000000 111111111 11111111  也就是所谓的低16位的开始
static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;
// 1 << 16 -1 代表1左位移16再减去1，也就是 00000000 00000000 111111111 11111111  也就是所谓的低16位的开始
static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;

/** 
* 返回以计数表示的共享保留项数  >>> 代表无符号右移16位
* c 进行无符号右移16位  
* int总共32位，所以结果就是高16位全部替换为0，原先的低16位全部抛弃，原先的高16位变成低16位，而原先的高 * 16位代表的读锁，所以这个操作得到的结果就是当前资源被设置读锁的个数
*/
static int sharedCount(int c)    { return c >>> SHARED_SHIFT; }

/** 
* 返回以计数表示的独占保留数  & 代表与运算
* c 和 00000000 00000000 111111111 11111111 进行 & 运算 全1为1，别的都是0
* 也就是说 不论c的值是多少，和EXCLUSIVE_MASK进行&运算，得到的结果高16位一直都是0，低16位和c保持一致
* 换个说法，只要是当前资源加的是读锁，那么这个方法会一直返回0，也就对应了这个方法的名字返回写锁的数量
*/
static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }
```

回到正题，加锁的时候会调用sync.acquireShared(1)方法，acquireShared方法内部会先尝试获取锁

1、会获取当前的state值 赋值为 c = 0

2、判断有没有写锁 exclusiveCount(c) != 0

3、如果没有写锁，则对c进行无符号右移16位，赋值给r 得到 加读锁的个数为0

4、然后判断r是否小于MAX_COUNT，这一步判断当前加锁的个数是不是小于最大加锁数量

5、通过CAS更改c的值，c = c+ SHARED_UNIT,  也就是高16位+1

6、第一次加锁成功，结果就是state值为 00000000 00000001 00000000 00000000

```java
//只显示和位运算相关的代码
/**
* exclusiveCount(c) != 0 这个条件只有在 c = 0的情况下，exclusiveCount(c) 才会等于0
* 第一次加锁，c=0，所以当前判断会跳过
*/
if (exclusiveCount(c) != 0 && getExclusiveOwnerThread() != current) return -1;

int r = sharedCount(c);

if (!readerShouldBlock() &&
                r < MAX_COUNT &&
                compareAndSetState(c, c + SHARED_UNIT)){...}
                
```

如果是第二次加读锁，整个过程如下：

1、获取当前state值，赋值为c = 00000000 00000001 00000000 00000000

2、判断有没有写锁exclusiveCount(c) != 0

3、则对c进行无符号右移16位，赋值给r 得到 加读锁的个数为1

4、CAS更改c的值，c = c+ SHARED_UNIT,  也就是高16位+1

5、第二次加锁成功，结果就是state值为 00000000 00000010 00000000 00000000

------

#### 1.2.2、读锁 解锁

```java
//忽略线程代码解析....
for (;;) {
    int c = getState();
    int nextc = c - SHARED_UNIT;
    if (compareAndSetState(c, nextc))
        return nextc == 0;
}
```

1、获取当前state值  00000000 00000010 00000000 00000000

2、在state高16位进行-1的操作 得到nextc = 00000000 00000001 00000000 00000000

3、CAS赋值，然后判断此时nextc是否==0，如果只有一个读锁的情况，那此时就是0 ，如果是多个读锁，则不是，返回false

------

#### 1.2.3、写锁 加锁

```java
int c = getState();
int w = exclusiveCount(c);
if (c != 0) {
    // (Note: if c != 0 and w == 0 then shared count != 0)
    if (w == 0 || current != getExclusiveOwnerThread())
        return false;
    if (w + exclusiveCount(acquires) > MAX_COUNT)
        throw new Error("Maximum lock count exceeded");
    // Reentrant acquire
    setState(c + acquires);
    return true;
}
if (writerShouldBlock() ||
                !compareAndSetState(c, c + acquires))
                return false;
setExclusiveOwnerThread(current);
return true;
```

1、获取当前state值 c = 0

2、获取当前写锁的个数 w = 0

3、如果c != 0,说明当前资源有被锁定，如果w==0，代表此时没有写锁，那肯定是有读锁，返回加锁失败

4、此时c = 0,执行13行，对c进行赋值+1，然后设置写锁线程为当前线程

------

如果是别的线程第二次加写锁：

1、获取当前state值 c = 1

2、获取当前写锁的个数 w 此时 w = 1

3、然后判断当前线程是不是已经加锁的线程，如果是则累加，如果不是则返回false

4、当前加锁线程进入队列等待

------

#### 1.2.4、写锁 解锁

```java
 if (!isHeldExclusively())
     throw new IllegalMonitorStateException();
int nextc = getState() - releases;
boolean free = exclusiveCount(nextc) == 0;
if (free)
    setExclusiveOwnerThread(null);
setState(nextc);
return free;
```

1、获取state 减去releases 1, 得到的结果nextc，

2、判断当前剩余的锁数量是否是0

3、如果是0则把Thead变量赋值为null

4、state 赋值nextc

## 2、HashMap中的位运算

