---
title: JVM概述
date: 2023-12-25 09:13:16
permalink: /be/935102/
categories:
  - JVM
tags:
  - JVM
author: 
  name: zhaoyb
  link: https://github.com/zhaoyb-coder
---

# JVM概述

### 1、JVM运行时区

![image-20231225135517480](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20231225135517480.png)

#### 1.1、程序计数器

程序计数器就是当前线程执行的行数指示器

#### 1.2、虚拟机栈/本地方法栈

Hot-Spot 虚拟机把虚拟机栈和本地方法栈合二为一，内部主要存储局部变量表、操作数栈、动态连接、方法出口等信息

每一个方法从调用到执行完毕的过程，就是一个栈帧在虚拟机栈中从入栈到出栈的过程

#### 1.4、堆

#### 1.5、方法区

存储的是被虚拟机加载的类型信息、常量、静态变量、即时编译后代码缓存等数据

#### 1.6、直接内存

直接内存代表着不是JVM内存的一部分，属于操作系统内存，但是也可以被JVM使用，比如引入NIO之后可以使用Native函数库直接分配堆外内存，然后存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样的场景可以提交效率，避免在Java堆和Native堆进行来回复制数据。

直接内存的大小可以根据-XX：MaxDirectMemorySize来设置，如果不进行设置，则大小与堆的最大值-Xmx一致。

### 2、Java对象

#### 2.1、如何分配对象内存

+ **指针碰撞**
  如果堆中的内存是完全规整的，所有未被使用的内存都被放在一起，那么分配一个对象内存只需要把指针向空闲的内存方向移动一定的距离就可以了。
+ **空闲列表**
  如果堆中的内存并不规整，已使用内存和空闲内存交叉在一起，那么JVM需要维护一个空闲内存的列表，在分配内存的时候从列表中取出足够大的空间划分为实例对象。

具体使用哪种方式进行内存分配，需要根据内存是否规整来决定；内存是否规整，取决于JVM使用哪种垃圾收集器；当使用的是Serial、ParNew等带有压缩整理的收集器时，系统采用的是指针碰撞来分配内存；当使用CMS来当做垃圾收集器时，理论上只能使用空闲列表来分配内存

除了划分可用内存之外，还有一个需要考虑的问题，就是并发问题。如果对A分配内存的时候，这块内存同时被B使用了，这种问题有两种解决方案：

一种是进行同步处理，虚拟机使用CAS的失败重试进行内存分配，来保证更新内存的原子性

一种是每个线程在JVM堆中预先分配一小块内存（**本地线程分配缓冲区Thread Local Allocation Buffer TLAB**），线程先在TLAB中分配内存，如果内存分配完了，后续在需要进行同步分配；

虚拟机是否使用TLAB，使用参数控制 -XX: +/-UseTLAB

#### 2.2、对象的组成

对象在堆内的存储布局分为三个部分：**对象头(Header)、实例数据(Instance)和对齐填充(Padding)**

##### 2.3.1、对象头

对象头分为两类信息

1、存储对象自身的运行时数据 （Mark Word）

+ 哈希码(HashCode)
+ GC分代年龄
+ 锁状态标志
+ 线程持有的锁
+ 偏向线程ID
+ 偏向时间戳
+ 等

2、类型指针

JVM通过这个指针来确定该对象是哪一个类的实例

此外，如果对象是一个数组，那么对象头还必须要存储数组长度。

##### 2.3.2、对齐填充

并不是必须的，仅仅是占位符的作用。因为HotSpot 虚拟机要求对象的起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍。对象头已经被精心设计为了8字节的整数倍（1或者2），以为如果实例对象的大小不满足8字节的整数倍，那么缺少的部分将由对齐填充来补全

#### 2.3、对象的访问

Java程序使用对象的方式是在栈上的reference数据来操作对堆中的具体对象。如何定位到堆中的实例化对象，一般有两种方法作为实现：句柄和指针 （HotSpot主要使用指针）

1、如果使用句柄的话，在java堆中需要单独划分一块内存作为句柄池，reference中存储的对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息；

`使用句柄的好处就是reference中存储的是稳定的句柄地址，在对象移动时（GC移动对象）改变的只是句柄中的实例数据指针，而reference本身不需要更改`

![image-20231225153029023](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20231225153029023.png)

2、使用指针直接访问对象，reference存储的直接就是对象地址

`使用指针的好处就是能直接访问对象，少了一次中间的开销`

![image-20231225153400409](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20231225153400409.png)

### 3、垃圾收集

> Java 与 C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想 进去，墙里面的人却想出来