---
title: VUE-概述
date: 2024-01-12 14:24:38
permalink: /fe/VUE01/
categories:
  - VUE
tags:
  - VUE
author: 
  name: zhaoyb
  link: https://github.com/zhaoyb-coder
---

#  VUE-概述

## 1、生命周期

简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数

```js
<div id="app">{{msg}}</div>

<script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"></script>
<script>
  var vm = new Vue({
    el: '#app',
    data: {
      msg: 'Vue的生命周期'
    },
    beforeCreate: function() {
      console.group('------beforeCreate创建前状态------');
      console.log("el     : " + this.$el); //undefined
      console.log("data   : " + this.$data); //undefined
      console.log("msg: " + this.msg) //undefined
    },
    created: function() {
      console.group('------created创建完毕状态------');
      console.log("el     : " + this.$el); //undefined
      console.log("data   : " + this.$data); //已被初始化
      console.log("msg: " + this.msg); //已被初始化
    },
    beforeMount: function() {
      console.group('------beforeMount挂载前状态------');
      console.log(this.$el);// <div id="app">{{msg}}</div> 挂载前状态
    },
    mounted: function() {
      console.group('------mounted 挂载结束状态------');
      console.log(this.$el);// <div id="app">Vue的生命周期</div>   msg内容被挂载并渲染到页面
    },
      // 当data被修改之前
    beforeUpdate: function () {
      console.group('beforeUpdate 更新前状态===============》');
      console.log("el     : " + this.$el);
      console.log(this.$el);
      console.log("data   : " + this.$data);
      console.log("msg: " + this.msg);
    },
      // 触发beforeUpdate之后，虚拟DOM重新渲染并应用更新
      // 当data被修改之后
    updated: function () {
      console.group('updated 更新完成状态===============》');
      console.log("el     : " + this.$el);
      console.log(this.$el);
      console.log("data   : " + this.$data);
      console.log("msg: " + this.msg);
    },
      // 调用vm.$destroy() 销毁前
    beforeDestroy: function () {
      console.group('beforeDestroy 销毁前状态===============》');
      console.log("el     : " + this.$el);
      console.log(this.$el);
      console.log("data   : " + this.$data);
      console.log("msg: " + this.msg);
    },
       // 调用vm.$destroy() 销毁后
    destroyed: function () {
      console.group('destroyed 销毁完成状态===============》');
      console.log("el     : " + this.$el);
      console.log(this.$el);
      console.log("data   : " + this.$data);
      console.log("msg: " + this.msg)
    }
  })
</script>
```

![组件生命周期图示](https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/lifecycle.DLmSwRQE.png)

## 2、组件间传递数据

### 2-1、父组件给子组件传值

父组件中，通过给子组件标签v-bind绑定属性的方式传入值

```js
<ComponentName v-bind:name="value"></ComponentName>
```

子组件中，通过props对象接收值组件中，通过props对象接收值

```js
 props: {
    name: { // 接收父组件传入值
        type: String || ...,
        default: ''
    }
 }
```

**子组件不能直接修改父组件传入的值**

这里有两种常见的试图改变一个 prop 的情形：

1. 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：

```js
props: ['initialCounter'],
data: function () {
  return {
    counter: this.initialCounter
  }
}
```

2. 这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：

```js
props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
```

### 2-2、子组件给父组件传值

子组件通过`$emit`派发事件和值给父组件（值可以有多个）

```js
this.$emit('fnX', value)
```

父组件通过`v-on`绑定子组件派发的事件，并触发一个新的事件，新的事件内可以接收传来的值

```js
<ComponentName @fnX="fnY"></ComponentName>

methods: {
	fnY(value) {
		console.log(value)
	}
}
```

